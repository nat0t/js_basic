// Будет выведено undefined, поскольку для var не существует блочной области видимости (в данном случае объявляется в глобальном контексте). Соответственно на момент проверки условия переменная "a" уже считается объявленной и является свойством window. Далее проверка условия даёт false, и присваивание значения не происходит.
if (!("a" in window)) {
    var a = 1;
}
alert(a);

// Будет выведена ошибка "a is not defined". Так происходит, потому что в данном случае использовано именованное функциональное выражение. Соответственно имя функции "a" доступно только изнутри самой функции.
var b = function a(x) {
    x && a(--x);
};
alert(a);

// Будет выведен код функции "a". Повторное объявление переменной не инициализирует её значение. Осталось актуальным только для старого кода, где используется var. Let/const покажут ошибку "Previously declared".
function a(x) {
    return x * 2;
}
var a;
alert(a);

// Будет выведено 10. Arguments - подобный массиву объект, содержащий аргументы, переданные в функцию. Следовательно внутри функции обращения "arguments[2]" и "a" идентичны.
function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);

// Будет выведен [object Window]. Вызов call() с параметром null равнозначен вызову без аргументов, а значит функция будет вызвана в контексте window.
function a() {
    alert(this);
}
a.call(null);